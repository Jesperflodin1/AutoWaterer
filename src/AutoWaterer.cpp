/*
 * AutoWaterer.ino -- part of the AutoWaterer project.
 * Setup of SerialUI and menu system
 * Jesper Flodin
 *  
 * 
 * Copyright (C) 2017 Jesper Flodin
 * 
 * Generated by DruidBuilder [https://devicedruid.com/], 
 * as part of project "ea6579bd13f7487a9a683140077ffaa5oexB3WpKKC",
 * aka AutoWaterer.
 * 
 * Druid4Arduino, Device Druid, Druid Builder, the builder 
 * code brewery and its wizards, SerialUI and supporting 
 * libraries, as well as the generated parts of this program 
 * are 
 *            Copyright (C) 2013-2019 Pat Deegan 
 * [https://psychogenic.com/ | https://inductive-kickback.com/]
 * and distributed under the terms of their respective licenses.
 * See https://devicedruid.com for details.
 * 
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
 * THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE 
 * PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, 
 * YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
 * CORRECTION.
 * 
 * Keep in mind that there is no warranty and you are solely 
 * responsible for the use of all these cool tools.
 * 
 * Play safe, have fun.
 * 
 */
#include <AceTMI.h>
#include <digitalWriteFast.h>
#include <ace_tmi/SimpleTmi1637FastInterface.h>
#include <AceSegment.h> // Tm1637Module
#include <AceSegmentWriter.h> 
#include "AutoWaterer.h"
#if SERIALUI_VERSION_AT_LEAST(3,2)
// all is well, you have a valid SerialUI lib installed...
#else
#error "Need SerialUI version 3.2 or greater"
#endif

/* --- Constants --- */

// Many TM1637 LED modules contain 10 nF capacitors on their DIO and CLK lines
// which are unreasonably high. This forces a 100 microsecond delay between
// bit transitions. If you remove those capacitors, you can set this as low as
// 1-5 micros.
const uint8_t DELAY_MICROS = 100;

const uint8_t HUMIDITYPOWER_PIN[NUM_SENSORS] = {2, 3, 4};
const uint8_t HUMIDITYSEN_PIN[NUM_SENSORS] = {A1, A2, A3};    // Sensor data pin for analog read
const uint8_t RELAY_PIN[NUM_SENSORS] = {8, 9, 10};

// 7 segment display
const uint8_t CLK_PIN = A0;
const uint8_t DIO_PIN = 7;
const uint8_t NUM_DIGITS = 4;

/* --- Global variables --- */

unsigned long currentMillis = 0;       // stores the value of millis() in each iteration of loop()
unsigned long prevMillisLedUpdate = 0; // time of previous led 7 segment display update

SerialUI::Menu::Item::Request::UnsignedLong humidityCheckInterval = CFG_HumidityInterval;

Sensor Sensors[NUM_SENSORS];
SensorConfig SensorsConfig[NUM_SENSORS];

/* --- 7 segment display --- */
using ace_tmi::SimpleTmi1637FastInterface;
using ace_segment::LedModule;
using ace_segment::Tm1637Module;
//using ace_segment::StringWriter;
using ace_segment::CharWriter;
using ace_segment::NumberWriter;
using TmiInterface = SimpleTmi1637FastInterface<DIO_PIN, CLK_PIN, DELAY_MICROS>;
TmiInterface tmiInterface;
Tm1637Module<TmiInterface, NUM_DIGITS> ledModule(tmiInterface);
CharWriter<LedModule> charWriter(ledModule);
//StringWriter<LedModule> stringWriter(charWriter);
NumberWriter<LedModule> numberWriter(ledModule);


void error(uint8_t);

void updateLed(uint8_t sensor, uint8_t humidity) {
  if (humidity == 100) humidity = 99;
  numberWriter.writeHexCharAt(0, sensor+1);
  charWriter.writeCharAt(1, '-');
  numberWriter.writeDec2At(2, humidity);
  ledModule.flush();
}
void error(uint8_t errCode) {
  charWriter.writeCharAt(0, 'E');
  charWriter.writeCharAt(1, 'R');
  charWriter.writeCharAt(2, 'R');
  numberWriter.writeHexCharAt(3, errCode+1);
  ledModule.flush();
  //delay(3000);
}

void readHumidity(uint8_t sensor) {

  digitalWriteFast(HUMIDITYPOWER_PIN[sensor], HIGH); //Power on humidity sensor
  delay(200);
  Sensors[sensor].rawHumidity = analogRead(HUMIDITYSEN_PIN[sensor]);
  delay(200);
  digitalWriteFast(HUMIDITYPOWER_PIN[sensor], LOW); //Power off sensor

  //Convert analog values
  Sensors[sensor].humidity = constrain((unsigned int)Sensors[sensor].rawHumidity, (unsigned int)SensorsConfig[sensor].calWet, (unsigned int)SensorsConfig[sensor].calDry);   // accept values between these limits for 4.8V on sensor 
  Sensors[sensor].humidity  = map(Sensors[sensor].humidity , (unsigned int)SensorsConfig[sensor].calWet, (unsigned int)SensorsConfig[sensor].calDry, 100, 0); // and map them between 0 and 100%
}
void pump(uint8_t sensor) {
  digitalWriteFast(RELAY_PIN[sensor], HIGH);
  delay((int)SensorsConfig[sensor].wateringTime * 1000);
  digitalWriteFast(RELAY_PIN[sensor], LOW);
  SensorsConfig[sensor].npump++; //Count the pumping
}

void initSensors() {
  for (int i=0; i<NUM_SENSORS; i++) {
    if ((bool)SensorsConfig[i].enable == true) { //If current sensor is enabled
      readHumidity(i);
        
      if (Sensors[i].humidity == 0) {
          error(i);
      } else {
        //prevMillisLedUpdate += 2000UL;
        updateLed(i, Sensors[i].humidity);          
      }
    }
  }   
}

/* **** standard setup() function **** */
void setup() {
  tmiInterface.begin();
  ledModule.begin();
  ledModule.setBrightness(2);
  //charWriter.writeCharAt(0, 'B');
  //charWriter.writeCharAt(1, 'O');
  //charWriter.writeCharAt(2, 'O');
  //charWriter.writeCharAt(3, 'T');
  //ledModule.flush();
  //delay(2000);

  pinMode(HUMIDITYPOWER_PIN[0], OUTPUT);
  pinMode(HUMIDITYPOWER_PIN[1], OUTPUT);
  pinMode(HUMIDITYPOWER_PIN[2], OUTPUT);
  pinMode(HUMIDITYSEN_PIN[0], INPUT);
  pinMode(HUMIDITYSEN_PIN[1], INPUT);
  pinMode(HUMIDITYSEN_PIN[2], INPUT);
  pinMode(RELAY_PIN[0], OUTPUT);
  pinMode(RELAY_PIN[1], OUTPUT);
  pinMode(RELAY_PIN[2], OUTPUT);
  //wdt_disable();

  initData();
	if (!SetupSerialUI()) {
		DIE_HORRIBLY(F("Problem during setup"));
	}
  
  uint8_t cfgVer = SetupConfig();

  charWriter.writeCharAt(0, 'V');
  charWriter.writeCharAt(1, '-');
  numberWriter.writeDec2At(2, cfgVer);
  ledModule.flush();
  delay(500);

  initSensors();
}


void loop() {
  if (MySUI.checkForUser()) {
    /* Now we keep handling the serial user's
    ** requests until they exit or timeout.
    */
   
    while (MySUI.userPresent()) {
      // actually respond to requests, using
      MySUI.handleRequests();
    }
  } /* end if we had a user on the serial line */

  currentMillis = millis();   // capture the latest value of millis()
                              //   this is equivalent to noting the time from a clock
  
  for (int i=0; i<NUM_SENSORS; i++) {
    if ((bool)SensorsConfig[i].enable == true) { //If current sensor is enabled

      if (currentMillis - Sensors[i].prevMillisHumCheck >= (unsigned long)humidityCheckInterval * 1000UL) { 
        Sensors[i].prevMillisHumCheck += (unsigned long)humidityCheckInterval * 1000UL;
        readHumidity(i);
        
        if (Sensors[i].humidity == 0) {
            error(i);
        } else {
          prevMillisLedUpdate += 2000UL;
          updateLed(i, Sensors[i].humidity);          
        }        
        
        if (currentMillis - Sensors[i].prevMillisWater >= (unsigned long)SensorsConfig[i].minTimeInterval*60UL*60UL*1000UL) {
          SensorsConfig[i].npump = 0;        
        } 

        //Maxtime elapsed or humidity low
        if ( (currentMillis - Sensors[i].prevMillisWater >= (unsigned long)SensorsConfig[i].maxTimeInterval*60UL*60UL*1000UL && SensorsConfig[i].npump < 2) || (Sensors[i].humidity <= SensorsConfig[i].limit && SensorsConfig[i].npump < 2) ) {
          //MySUI.print(currentMillis); MySUI.print(" "); MySUI.print(Sensors[i].prevMillisWater); MySUI.print(" "); MySUI.println(SensorsConfig[i].npump);
          Sensors[i].prevMillisWater = currentMillis;
          pump(i);
        }         
      }
      static uint8_t lastUpdatedSensor = NUM_SENSORS-1;     
      if (currentMillis - prevMillisLedUpdate >= 2000UL && i == (lastUpdatedSensor == NUM_SENSORS-1 ? 0 : lastUpdatedSensor+1)) {
        lastUpdatedSensor = lastUpdatedSensor == NUM_SENSORS-1 ? 0 : lastUpdatedSensor+1;
        prevMillisLedUpdate += 2000UL;
        updateLed(i, Sensors[i].humidity);                 
      }
    }    
  }
}